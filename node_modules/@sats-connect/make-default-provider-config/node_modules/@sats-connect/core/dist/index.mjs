// src/types.ts
var BitcoinNetworkType = /* @__PURE__ */ ((BitcoinNetworkType2) => {
  BitcoinNetworkType2["Mainnet"] = "Mainnet";
  BitcoinNetworkType2["Testnet"] = "Testnet";
  return BitcoinNetworkType2;
})(BitcoinNetworkType || {});
var RpcErrorCode = /* @__PURE__ */ ((RpcErrorCode2) => {
  RpcErrorCode2[RpcErrorCode2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  RpcErrorCode2[RpcErrorCode2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  RpcErrorCode2[RpcErrorCode2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  RpcErrorCode2[RpcErrorCode2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  RpcErrorCode2[RpcErrorCode2["USER_REJECTION"] = -32e3] = "USER_REJECTION";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_SUPPORTED"] = -32001] = "METHOD_NOT_SUPPORTED";
  return RpcErrorCode2;
})(RpcErrorCode || {});

// src/runes/index.ts
import axios from "axios";
var ORDINALS_API_BASE_URL = (network = "Mainnet" /* Mainnet */) => `https://ordinals${network === "Testnet" /* Testnet */ ? "-testnet" : ""}.xverse.app/v1`;
var RunesApi = class {
  client;
  constructor(network) {
    this.client = axios.create({
      baseURL: ORDINALS_API_BASE_URL(network)
    });
  }
  parseError = (error) => {
    return {
      code: error.response?.status,
      message: JSON.stringify(error.response?.data)
    };
  };
  estimateMintCost = async (mintParams) => {
    try {
      const response = await this.client.post("/runes/mint/estimate", {
        ...mintParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  estimateEtchCost = async (etchParams) => {
    try {
      const response = await this.client.post("/runes/etch/estimate", {
        ...etchParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createMintOrder = async (mintOrderParams) => {
    try {
      const response = await this.client.post("/runes/mint/orders", {
        ...mintOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createEtchOrder = async (etchOrderParams) => {
    try {
      const response = await this.client.post("/runes/etch/orders", {
        ...etchOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeMint = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/mint/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeEtch = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/etch/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  getOrder = async (orderId) => {
    try {
      const response = await this.client.get(`/orders/${orderId}`);
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
};
var testnetClient = new RunesApi("Testnet" /* Testnet */);
var mainnetClient = new RunesApi("Mainnet" /* Mainnet */);
var getRunesApiClient = (network = "Mainnet" /* Mainnet */) => network === "Mainnet" /* Mainnet */ ? mainnetClient : testnetClient;

// src/adapters/satsConnectAdapter.ts
var SatsConnectAdapter = class {
  async mintRunes(params) {
    try {
      const mintRequest = {
        destinationAddress: params.destinationAddress,
        feeRate: params.feeRate,
        refundAddress: params.refundAddress,
        repeats: params.repeats,
        runeName: params.runeName,
        appServiceFee: params.appServiceFee,
        appServiceFeeAddress: params.appServiceFeeAddress
      };
      const orderResponse = await new RunesApi(params.network).createMintOrder(mintRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse?.status !== "success") {
        return {
          status: "error",
          error: {
            code: -32e3 /* USER_REJECTION */,
            message: "User rejected the payment request"
          }
        };
      }
      await new RunesApi(params.network).executeMint(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async etchRunes(params) {
    const etchRequest = {
      destinationAddress: params.destinationAddress,
      refundAddress: params.refundAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    try {
      const orderResponse = await new RunesApi(params.network).createEtchOrder(etchRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse?.status !== "success") {
        return {
          status: "error",
          error: {
            code: -32e3 /* USER_REJECTION */,
            message: "User rejected the payment request"
          }
        };
      }
      await new RunesApi(params.network).executeEtch(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async estimateMint(params) {
    const estimateMintRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      repeats: params.repeats,
      runeName: params.runeName,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(
      params.network
    ).estimateMintCost(estimateMintRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async estimateEtch(params) {
    const estimateEtchRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(params.network).estimateEtchCost(estimateEtchRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async getOrder(params) {
    const response = await getRunesApiClient(params.network).getOrder(params.id);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async request(method, params) {
    switch (method) {
      case "runes_mint":
        return this.mintRunes(params);
      case "runes_etch":
        return this.etchRunes(params);
      case "runes_estimateMint":
        return this.estimateMint(params);
      case "runes_estimateEtch":
        return this.estimateEtch(params);
      case "runes_getOrder": {
        return this.getOrder(params);
      }
      default:
        return this.requestInternal(method, params);
    }
  }
};

// src/provider/index.ts
import omit from "lodash.omit";
async function getProviderOrThrow(getProvider) {
  const provider = await getProvider?.() || window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (!provider) {
    throw new Error("No Bitcoin wallet installed");
  }
  return provider;
}
function getProviders() {
  if (!window.btc_providers)
    window.btc_providers = [];
  return window.btc_providers;
}
function getProviderById(providerId) {
  return providerId?.split(".").reduce((acc, part) => acc?.[part], window);
}
function isProviderInstalled(providerId) {
  return !!getProviderById(providerId);
}
function setDefaultProvider(providerId) {
  localStorage.setItem("sats-connect_defaultProvider", providerId);
}
function getDefaultProvider() {
  return localStorage.getItem("sats-connect_defaultProvider");
}
function removeDefaultProvider() {
  localStorage.removeItem("sats-connect_defaultProvider");
}
function getSupportedWallets() {
  const btc_providers = getProviders();
  const allProviders = [...btc_providers];
  for (const key in omit(DefaultAdaptersInfo, ["xverse"])) {
    allProviders.push(DefaultAdaptersInfo[key]);
  }
  const wallets = allProviders.map((provider) => {
    {
      return {
        ...provider,
        isInstalled: isProviderInstalled(provider.id)
      };
    }
  });
  return wallets;
}

// src/request/index.ts
var request = async (method, params, providerId) => {
  let provider = window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (providerId) {
    provider = await getProviderById(providerId);
  }
  if (!provider) {
    throw new Error("no wallet provider was found");
  }
  if (!method) {
    throw new Error("A wallet method is required");
  }
  const response = await provider.request(method, params);
  if (isRpcSuccessResponse(response)) {
    return {
      status: "success",
      result: response.result
    };
  }
  return {
    status: "error",
    error: response.error
  };
};
var isRpcSuccessResponse = (response) => {
  return Object.hasOwn(response, "result") && !!response.result;
};

// src/adapters/xverse.ts
var XverseAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.xverse.id;
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
};

// src/adapters/unisat.ts
import { Buffer } from "buffer";
import { AddressType as AddressType2, getAddressInfo } from "bitcoin-address-validation";

// src/addresses/index.ts
import { createUnsecuredToken } from "jsontokens";

// src/addresses/types.ts
var AddressPurpose = /* @__PURE__ */ ((AddressPurpose2) => {
  AddressPurpose2["Ordinals"] = "ordinals";
  AddressPurpose2["Payment"] = "payment";
  AddressPurpose2["Stacks"] = "stacks";
  return AddressPurpose2;
})(AddressPurpose || {});
var AddressType = /* @__PURE__ */ ((AddressType3) => {
  AddressType3["p2pkh"] = "p2pkh";
  AddressType3["p2sh"] = "p2sh";
  AddressType3["p2wpkh"] = "p2wpkh";
  AddressType3["p2wsh"] = "p2wsh";
  AddressType3["p2tr"] = "p2tr";
  AddressType3["stacks"] = "stacks";
  return AddressType3;
})(AddressType || {});

// src/addresses/index.ts
var getAddress = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { purposes } = options.payload;
  if (!purposes) {
    throw new Error("Address purposes are required");
  }
  try {
    const request2 = createUnsecuredToken(options.payload);
    const response = await provider.connect(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during address request", error);
    options.onCancel?.();
  }
};

// src/adapters/unisat.ts
function convertSignInputsToInputType(signInputs, allowedSignHash) {
  let result = [];
  for (let address in signInputs) {
    let indexes = signInputs[address];
    for (let index of indexes) {
      result.push({
        index,
        address,
        sighashTypes: allowedSignHash ? [allowedSignHash] : void 0
      });
    }
  }
  return result;
}
var UnisatAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.unisat.id;
  async getAccounts(params) {
    const { purposes } = params;
    if (purposes.includes("stacks" /* Stacks */)) {
      throw new Error("Only bitcoin addresses are supported");
    }
    const accounts = await window.unisat.requestAccounts();
    const publicKey = await window.unisat.getPublicKey();
    const address = accounts[0];
    const addressType = getAddressInfo(accounts[0]).type;
    const pk = addressType === AddressType2.p2tr ? publicKey.slice(2) : publicKey;
    const paymentAddress = {
      address,
      publicKey: pk,
      addressType,
      purpose: "payment" /* Payment */
    };
    const ordinalsAddress = {
      address,
      publicKey: pk,
      addressType,
      purpose: "ordinals" /* Ordinals */
    };
    const response = [];
    if (purposes.includes("payment" /* Payment */)) {
      response.push(paymentAddress);
    }
    if (purposes.includes("ordinals" /* Ordinals */)) {
      response.push(ordinalsAddress);
    }
    return response;
  }
  async signMessage(params) {
    const { message, address } = params;
    const addressType = getAddressInfo(address).type;
    const Bip322supportedTypes = [AddressType2.p2wpkh, AddressType2.p2tr];
    if (Bip322supportedTypes.includes(addressType)) {
      const response2 = await window.unisat.signMessage(message, "bip322-simple");
      return {
        address,
        messageHash: "",
        signature: response2
      };
    }
    const response = await window.unisat.signMessage(message, "ecdsa");
    return {
      address,
      messageHash: "",
      signature: response
    };
  }
  async sendTransfer(params) {
    const { recipients } = params;
    if (recipients.length > 1) {
      throw new Error("Only one recipient is supported by this wallet provider");
    }
    const txid = await window.unisat.sendBitcoin(recipients[0].address, recipients[0].amount);
    return {
      txid
    };
  }
  async signPsbt(params) {
    const { psbt, signInputs, allowedSignHash, broadcast } = params;
    const psbtHex = Buffer.from(psbt, "base64").toString("hex");
    const signedPsbt = await window.unisat.signPsbt(psbtHex, {
      autoFinalized: broadcast,
      toSignInputs: convertSignInputsToInputType(signInputs, allowedSignHash)
    });
    if (broadcast) {
      const txid = await window.unisat.pushPsbt(psbtHex);
      return {
        psbt: signedPsbt,
        txid
      };
    }
    return {
      psbt: psbtHex
    };
  }
  requestInternal = async (method, params) => {
    try {
      switch (method) {
        case "getAccounts": {
          const response = await this.getAccounts(
            params
          );
          return {
            status: "success",
            result: response
          };
        }
        case "sendTransfer": {
          const response = await this.sendTransfer(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signMessage": {
          const response = await this.signMessage(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signPsbt": {
          const response = await this.signPsbt(params);
          return {
            status: "success",
            result: response
          };
        }
        default: {
          const error = {
            code: -32001 /* METHOD_NOT_SUPPORTED */,
            message: "Method not supported by the selected wallet"
          };
          console.error("Error calling the method", error);
          return {
            status: "error",
            error
          };
        }
      }
    } catch (error) {
      console.error("Error calling the method", error);
      return {
        status: "error",
        error: {
          code: error.code === 4001 ? -32e3 /* USER_REJECTION */ : -32603 /* INTERNAL_ERROR */,
          message: error.message ? error.message : "Wallet method call error",
          data: error
        }
      };
    }
  };
};

// src/adapters/BaseAdapter.ts
var BaseAdapter = class extends SatsConnectAdapter {
  id = "";
  constructor(providerId) {
    super();
    this.id = providerId;
  }
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
};

// src/adapters/index.ts
var DefaultAdaptersInfo = {
  xverse: {
    id: "XverseProviders.BitcoinProvider",
    name: "Xverse",
    webUrl: "https://www.xverse.app/",
    googlePlayStoreUrl: "https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse",
    iOSAppStoreUrl: "https://apps.apple.com/app/xverse-bitcoin-web3-wallet/id1552272513",
    chromeWebStoreUrl: "https://chromewebstore.google.com/detail/xverse-wallet/idnnbdplmphpflfnlkomgpfbpcgelopg",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgdmlld0JveD0iMCAwIDEwMiAxMDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGlkPSJJY29uX0FydCAoRWRpdCBNZSkiPgo8cmVjdCB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgZmlsbD0iIzE4MTgxOCIvPgo8ZyBpZD0iTG9nby9FbWJsZW0iIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMF8xMjIzKSI+CjxwYXRoIGlkPSJWZWN0b3IiIGQ9Ik03NC42NTQyIDczLjg4ODNWNjUuMjMxMkM3NC42NTQyIDY0Ljg4OCA3NC41MTc3IDY0LjU2MDYgNzQuMjc0NSA2NC4zMTc0TDM3LjQzOTcgMjcuNDgyNUMzNy4xOTY1IDI3LjIzOTIgMzYuODY5MSAyNy4xMDI4IDM2LjUyNTggMjcuMTAyOEgyNy44NjlDMjcuNDQxNiAyNy4xMDI4IDI3LjA5MzggMjcuNDUwNiAyNy4wOTM4IDI3Ljg3OFYzNS45MjExQzI3LjA5MzggMzYuMjY0NCAyNy4yMzAyIDM2LjU5MTcgMjcuNDczNCAzNi44MzVMNDAuNjk1MiA1MC4wNTY3QzQwLjk5NzUgNTAuMzU5MSA0MC45OTc1IDUwLjg1MDEgNDAuNjk1MiA1MS4xNTI0TDI3LjMyMTEgNjQuNTI2NUMyNy4xNzU2IDY0LjY3MiAyNy4wOTM4IDY0Ljg2OTggMjcuMDkzOCA2NS4wNzQ0VjczLjg4ODNDMjcuMDkzOCA3NC4zMTUzIDI3LjQ0MTYgNzQuNjYzNSAyNy44NjkgNzQuNjYzNUg0Mi4zMzQyQzQyLjc2MTYgNzQuNjYzNSA0My4xMDk0IDc0LjMxNTMgNDMuMTA5NCA3My44ODgzVjY4LjY5NThDNDMuMTA5NCA2OC40OTEyIDQzLjE5MTIgNjguMjkzNSA0My4zMzY4IDY4LjE0NzlMNTAuNTExNCA2MC45NzMzQzUwLjgxMzggNjAuNjcwOSA1MS4zMDQ4IDYwLjY3MDkgNTEuNjA3MiA2MC45NzMzTDY0LjkxOTggNzQuMjg2MUM2NS4xNjMxIDc0LjUyOTMgNjUuNDkwNCA3NC42NjU4IDY1LjgzMzcgNzQuNjY1OEg3My44NzY3Qzc0LjMwNDIgNzQuNjY1OCA3NC42NTE5IDc0LjMxNzYgNzQuNjUxOSA3My44OTA2TDc0LjY1NDIgNzMuODg4M1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGlkPSJWZWN0b3JfMiIgZD0iTTU1LjM1OCAzOC41NjcySDYyLjYwMzFDNjMuMDMyOCAzOC41NjcyIDYzLjM4MjkgMzguOTE3MyA2My4zODI5IDM5LjM0NjlWNDYuNTkyMUM2My4zODI5IDQ3LjI4NzcgNjQuMjI0IDQ3LjYzNTUgNjQuNzE1MSA0Ny4xNDIyTDc0LjY1NDEgMzcuMTg3M0M3NC43OTk0IDM3LjA0MTggNzQuODgxNiAzNi44NDQgNzQuODgxNiAzNi42MzcxVjI3LjkxODlDNzQuODgxNiAyNy40ODkyIDc0LjUzMzQgMjcuMTM5MSA3NC4xMDE3IDI3LjEzOTFMNjUuMjUzOCAyNy4xMjc3QzY1LjA0NyAyNy4xMjc3IDY0Ljg0OTIgMjcuMjA5NiA2NC43MDE0IDI3LjM1NTFMNTQuODA1NiAzNy4yMzVDNTQuMzE0NSAzNy43MjYgNTQuNjYyMyAzOC41NjcyIDU1LjM1NTcgMzguNTY3Mkg1NS4zNThaIiBmaWxsPSIjRUU3QTMwIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMF8xMjIzIj4KPHJlY3Qgd2lkdGg9IjQ3LjgxMjUiIGhlaWdodD0iNDcuODEyNSIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3LjA5MzggMjcuMDkzOCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K"
  },
  unisat: {
    id: "unisat",
    name: "Unisat",
    webUrl: "https://unisat.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTAwNTBfNDE3MSkiPgo8cGF0aCBkPSJNMTEzLjY2IDI5LjI4OTdMMTQzLjk3IDU5LjMwOTdDMTQ2LjU1IDYxLjg1OTcgMTQ3LjgyIDY0LjQzOTcgMTQ3Ljc4IDY3LjAzOTdDMTQ3Ljc0IDY5LjYzOTcgMTQ2LjYzIDcyLjAwOTcgMTQ0LjQ2IDc0LjE1OTdDMTQyLjE5IDc2LjQwOTcgMTM5Ljc0IDc3LjU0OTcgMTM3LjEyIDc3LjU5OTdDMTM0LjUgNzcuNjM5NyAxMzEuOSA3Ni4zNzk3IDEyOS4zMiA3My44Mjk3TDk4LjMxOTkgNDMuMTI5N0M5NC43OTk5IDM5LjYzOTcgOTEuMzk5OSAzNy4xNjk3IDg4LjEyOTkgMzUuNzE5N0M4NC44NTk5IDM0LjI2OTcgODEuNDE5OSAzNC4wMzk3IDc3LjgxOTkgMzUuMDM5N0M3NC4yMDk5IDM2LjAyOTcgNzAuMzM5OSAzOC41Nzk3IDY2LjE4OTkgNDIuNjc5N0M2MC40Njk5IDQ4LjM0OTcgNTcuNzM5OSA1My42Njk3IDU4LjAxOTkgNTguNjM5N0M1OC4yOTk5IDYzLjYwOTcgNjEuMTM5OSA2OC43Njk3IDY2LjUyOTkgNzQuMDk5N0w5Ny43Nzk5IDEwNS4wNkMxMDAuMzkgMTA3LjY0IDEwMS42NyAxMTAuMjIgMTAxLjYzIDExMi43OEMxMDEuNTkgMTE1LjM1IDEwMC40NyAxMTcuNzIgOTguMjU5OSAxMTkuOTFDOTYuMDU5OSAxMjIuMDkgOTMuNjI5OSAxMjMuMjMgOTAuOTg5OSAxMjMuMzJDODguMzQ5OSAxMjMuNDEgODUuNzE5OSAxMjIuMTYgODMuMTE5OSAxMTkuNThMNTIuODA5OSA4OS41NTk3QzQ3Ljg3OTkgODQuNjc5NyA0NC4zMTk5IDgwLjA1OTcgNDIuMTI5OSA3NS42OTk3QzM5LjkzOTkgNzEuMzM5NyAzOS4xMTk5IDY2LjQwOTcgMzkuNjg5OSA2MC45MDk3QzQwLjE5OTkgNTYuMTk5NyA0MS43MDk5IDUxLjYzOTcgNDQuMjI5OSA0Ny4yMTk3QzQ2LjczOTkgNDIuNzk5NyA1MC4zMzk5IDM4LjI3OTcgNTUuMDA5OSAzMy42NDk3QzYwLjU2OTkgMjguMTM5NyA2NS44Nzk5IDIzLjkxOTcgNzAuOTM5OSAyMC45Nzk3Qzc1Ljk4OTkgMTguMDM5NyA4MC44Nzk5IDE2LjQwOTcgODUuNTk5OSAxNi4wNjk3QzkwLjMyOTkgMTUuNzI5NyA5NC45ODk5IDE2LjY2OTcgOTkuNTk5OSAxOC44ODk3QzEwNC4yMSAyMS4xMDk3IDEwOC44OSAyNC41Njk3IDExMy42NSAyOS4yODk3SDExMy42NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxKSIvPgo8cGF0aCBkPSJNNjYuMTA5OSAxNTAuNDJMMzUuODA5OSAxMjAuNEMzMy4yMjk5IDExNy44NCAzMS45NTk5IDExNS4yNyAzMS45OTk5IDExMi42N0MzMi4wMzk5IDExMC4wNyAzMy4xNDk5IDEwNy43IDM1LjMxOTkgMTA1LjU1QzM3LjU4OTkgMTAzLjMgNDAuMDM5OSAxMDIuMTYgNDIuNjU5OSAxMDIuMTFDNDUuMjc5OSAxMDIuMDcgNDcuODc5OSAxMDMuMzIgNTAuNDU5OSAxMDUuODhMODEuNDQ5OSAxMzYuNThDODQuOTc5OSAxNDAuMDcgODguMzY5OSAxNDIuNTQgOTEuNjM5OSAxNDMuOTlDOTQuOTA5OSAxNDUuNDQgOTguMzQ5OSAxNDUuNjYgMTAxLjk2IDE0NC42N0MxMDUuNTcgMTQzLjY4IDEwOS40NCAxNDEuMTMgMTEzLjU5IDEzNy4wMkMxMTkuMzEgMTMxLjM1IDEyMi4wNCAxMjYuMDMgMTIxLjc2IDEyMS4wNkMxMjEuNDggMTE2LjA5IDExOC42NCAxMTAuOTMgMTEzLjI1IDEwNS41OUw5Ni41OTk5IDg5LjI0MDFDOTMuOTg5OSA4Ni42NjAxIDkyLjcwOTkgODQuMDgwMSA5Mi43NDk5IDgxLjUyMDFDOTIuNzg5OSA3OC45NTAxIDkzLjkwOTkgNzYuNTgwMSA5Ni4xMTk5IDc0LjM5MDFDOTguMzE5OSA3Mi4yMTAxIDEwMC43NSA3MS4wNzAxIDEwMy4zOSA3MC45ODAxQzEwNi4wMyA3MC44OTAxIDEwOC42NiA3Mi4xNDAxIDExMS4yNiA3NC43MjAxTDEyNi45NiA5MC4xMzAxQzEzMS44OSA5NS4wMTAxIDEzNS40NSA5OS42MzAxIDEzNy42NCAxMDMuOTlDMTM5LjgzIDEwOC4zNSAxNDAuNjUgMTEzLjI4IDE0MC4wOCAxMTguNzhDMTM5LjU3IDEyMy40OSAxMzguMDYgMTI4LjA1IDEzNS41NCAxMzIuNDdDMTMzLjAzIDEzNi44OSAxMjkuNDMgMTQxLjQxIDEyNC43NiAxNDYuMDRDMTE5LjIgMTUxLjU1IDExMy44OSAxNTUuNzcgMTA4LjgzIDE1OC43MUMxMDMuNzcgMTYxLjY1IDk4Ljg3OTkgMTYzLjI5IDk0LjE0OTkgMTYzLjYzQzg5LjQxOTkgMTYzLjk3IDg0Ljc1OTkgMTYzLjAzIDgwLjE0OTkgMTYwLjgxQzc1LjUzOTkgMTU4LjU5IDcwLjg1OTkgMTU1LjEzIDY2LjA5OTkgMTUwLjQxTDY2LjEwOTkgMTUwLjQyWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzEwMDUwXzQxNzEpIi8+CjxwYXRoIGQ9Ik04NS4wMDk5IDcyLjk1OTJDOTEuMTU2OCA3Mi45NTkyIDk2LjEzOTkgNjcuOTc2MSA5Ni4xMzk5IDYxLjgyOTJDOTYuMTM5OSA1NS42ODIzIDkxLjE1NjggNTAuNjk5MiA4NS4wMDk5IDUwLjY5OTJDNzguODYzIDUwLjY5OTIgNzMuODc5OSA1NS42ODIzIDczLjg3OTkgNjEuODI5MkM3My44Nzk5IDY3Ljk3NjEgNzguODYzIDcyLjk1OTIgODUuMDA5OSA3Mi45NTkyWiIgZmlsbD0idXJsKCNwYWludDJfcmFkaWFsXzEwMDUwXzQxNzEpIi8+CjwvZz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iMTM4Ljk4NSIgeTE9IjQ2Ljc3OTUiIHgyPSI0NS4wNTI5IiB5Mj0iODguNTIzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMjAxQzFCIi8+CjxzdG9wIG9mZnNldD0iMC4zNiIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRCODUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iNDMuMzgxMiIgeTE9IjEzNC4xNjciIHgyPSIxNTIuMjMxIiB5Mj0iMTAxLjc3MSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMUYxRDFDIi8+CjxzdG9wIG9mZnNldD0iMC4zNyIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRGQjUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQyX3JhZGlhbF8xMDA1MF80MTcxIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDg1LjAwOTkgNjEuODM5Mikgc2NhbGUoMTEuMTMpIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y0Qjg1MiIvPgo8c3RvcCBvZmZzZXQ9IjAuMzMiIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0IiBzdG9wLWNvbG9yPSIjNzczOTBEIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzIxMUMxRCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEwMDUwXzQxNzEiPgo8cmVjdCB3aWR0aD0iMTE1Ljc3IiBoZWlnaHQ9IjE0Ny43IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzIgMTYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
  }
};
var defaultAdapters = {
  [DefaultAdaptersInfo.xverse.id]: XverseAdapter,
  [DefaultAdaptersInfo.unisat.id]: UnisatAdapter
};

// src/capabilities/index.ts
import { createUnsecuredToken as createUnsecuredToken2 } from "jsontokens";
var extractOrValidateCapabilities = (provider, reportedCapabilities) => {
  const validateCapability = (capability) => {
    if (!provider[capability]) {
      return false;
    }
    if (reportedCapabilities && !reportedCapabilities.has(capability)) {
      return false;
    }
    return true;
  };
  const capabilityMap = {
    request: validateCapability("request"),
    connect: validateCapability("connect"),
    signMessage: validateCapability("signMessage"),
    signTransaction: validateCapability("signTransaction"),
    sendBtcTransaction: validateCapability("sendBtcTransaction"),
    createInscription: validateCapability("createInscription"),
    createRepeatInscriptions: validateCapability("createRepeatInscriptions"),
    signMultipleTransactions: validateCapability("signMultipleTransactions")
  };
  return Object.entries(capabilityMap).reduce((acc, [capability, value]) => {
    if (value)
      return [...acc, capability];
    return acc;
  }, []);
};
var getCapabilities = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const request2 = createUnsecuredToken2(options.payload);
  if (provider.getCapabilities) {
    try {
      const response = await provider.getCapabilities(request2);
      options.onFinish?.(extractOrValidateCapabilities(provider, new Set(response)));
    } catch (error) {
      console.error("[Connect] Error during capabilities request", error);
    }
  }
  try {
    const inferredCapabilities = extractOrValidateCapabilities(provider);
    options.onFinish?.(inferredCapabilities);
  } catch (error) {
    console.error("[Connect] Error during capabilities request", error);
    options.onCancel?.();
  }
};

// src/inscriptions/createInscription.ts
import { createUnsecuredToken as createUnsecuredToken3 } from "jsontokens";

// src/inscriptions/utils.ts
var MAX_CONTENT_LENGTH_MAINNET = 4e5;
var MAX_CONTENT_LENGTH_TESTNET = 6e4;
var validateInscriptionPayload = (payload) => {
  const { contentType, content, payloadType, network, appFeeAddress, appFee } = payload;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(contentType)) {
    throw new Error("Invalid content type detected");
  }
  if (!content || content.length === 0) {
    throw new Error("Empty content not allowed");
  }
  if (!payloadType || payloadType !== "BASE_64" && payloadType !== "PLAIN_TEXT") {
    throw new Error("Empty invalid payloadType specified");
  }
  if (content.length > (network.type === "Mainnet" ? MAX_CONTENT_LENGTH_MAINNET : MAX_CONTENT_LENGTH_TESTNET)) {
    throw new Error("Content too large");
  }
  if ((appFeeAddress?.length ?? 0) > 0 && (appFee ?? 0) <= 0) {
    throw new Error("Invalid combination of app fee address and fee provided");
  }
};

// src/inscriptions/createInscription.ts
var createInscription = async (options) => {
  const { getProvider } = options;
  const provider = await getProviderOrThrow(getProvider);
  validateInscriptionPayload(options.payload);
  try {
    const request2 = createUnsecuredToken3(options.payload);
    const response = await provider.createInscription(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during create inscription", error);
    options.onCancel?.();
  }
};

// src/inscriptions/createRepeatInscriptions.ts
import { createUnsecuredToken as createUnsecuredToken4 } from "jsontokens";
var createRepeatInscriptions = async (options) => {
  const { getProvider } = options;
  const provider = await getProviderOrThrow(getProvider);
  validateInscriptionPayload(options.payload);
  try {
    const request2 = createUnsecuredToken4(options.payload);
    const response = await provider.createRepeatInscriptions(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during create repeat inscriptions", error);
    options.onCancel?.();
  }
};

// src/messages/index.ts
import { createUnsecuredToken as createUnsecuredToken5 } from "jsontokens";
var signMessage = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { address, message } = options.payload;
  if (!address) {
    throw new Error("An address is required to sign a message");
  }
  if (!message) {
    throw new Error("A message to be signed is required");
  }
  try {
    const request2 = createUnsecuredToken5(options.payload);
    const response = await provider.signMessage(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign message request", error);
    options.onCancel?.();
  }
};

// src/transactions/sendBtcTransaction.ts
import { createUnsecuredToken as createUnsecuredToken6 } from "jsontokens";
var serializer = (recipient) => {
  return recipient.map((value) => {
    const { address, amountSats } = value;
    return {
      address,
      amountSats: amountSats.toString()
    };
  });
};
var sendBtcTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { recipients, senderAddress, network, message } = options.payload;
  if (!recipients || recipients.length === 0) {
    throw new Error("At least one recipient is required");
  }
  if (recipients.some(
    (item) => typeof item.address !== "string" || typeof item.amountSats !== "bigint"
  )) {
    throw new Error("Incorrect recipient format");
  }
  if (!senderAddress) {
    throw new Error("The sender address is required");
  }
  try {
    const serializedRecipients = serializer(recipients);
    const serializedPayload = {
      network,
      senderAddress,
      message,
      recipients: serializedRecipients
    };
    const request2 = createUnsecuredToken6(serializedPayload);
    const response = await provider.sendBtcTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during send BTC transaction request", error);
    options.onCancel?.();
  }
};

// src/transactions/signTransaction.ts
import { createUnsecuredToken as createUnsecuredToken7 } from "jsontokens";
var signTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbtBase64, inputsToSign } = options.payload;
  if (!psbtBase64) {
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  }
  if (!inputsToSign) {
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  }
  try {
    const request2 = createUnsecuredToken7(options.payload);
    const response = await provider.signTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign transaction request", error);
    options.onCancel?.();
  }
};

// src/transactions/signMultipleTransactions.ts
import { createUnsecuredToken as createUnsecuredToken8 } from "jsontokens";
var signMultipleTransactions = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbts } = options.payload;
  if (!psbts || !psbts.length) {
    throw new Error("psbts array is required");
  }
  if (psbts.length > 100) {
    throw new Error("psbts array must contain less than 100 psbts");
  }
  try {
    const request2 = createUnsecuredToken8(options.payload);
    const response = await provider.signMultipleTransactions(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign Multiple transactions request", error);
    options.onCancel?.();
  }
};
export {
  AddressPurpose,
  AddressType,
  BaseAdapter,
  BitcoinNetworkType,
  DefaultAdaptersInfo,
  RpcErrorCode,
  SatsConnectAdapter,
  createInscription,
  createRepeatInscriptions,
  defaultAdapters,
  getAddress,
  getCapabilities,
  getDefaultProvider,
  getProviderById,
  getProviderOrThrow,
  getProviders,
  getSupportedWallets,
  isProviderInstalled,
  removeDefaultProvider,
  request,
  sendBtcTransaction,
  setDefaultProvider,
  signMessage,
  signMultipleTransactions,
  signTransaction
};
